<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Park with Billboarding</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; }
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            cursor: pointer;
            z-index: 10;
        }
        p { margin: 5px 0; }
    </style>
</head>
<body>

    <div id="instructions">
        <h1>Click to Enter Park</h1>
        <p>Move: W, A, S, D</p>
        <p>Look: Mouse</p>
    </div>

    <!-- Import Three.js from CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        let camera, scene, renderer, controls;
        const objects = [];
        let raycaster;

        const DEFAULT_CHAT_MESSAGE = "Welcome to the Park!";
        const ASSISTANT_MESSAGE_EVENT = 'world-engine-assistant-message';
        let chatMaterial;
        let chatSprite;
        let pendingAssistantMessage = DEFAULT_CHAT_MESSAGE;

        // Movement variables
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        window.WorldEngine = window.WorldEngine || {};
        window.WorldEngine.receiveAssistantMessage = updateChatMessage;

        window.addEventListener(ASSISTANT_MESSAGE_EVENT, (event) => {
            const incoming = event?.detail?.message ?? event?.detail ?? '';
            updateChatMessage(incoming);
        });

        init();
        animate();

        function init() {
            // 1. Setup Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky Blue
            scene.fog = new THREE.Fog(0x87CEEB, 10, 100); // Fog for depth

            // 2. Setup Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.y = 1.6; // Average eye height (1.6 meters)
            camera.position.z = 10;  // Start back a bit

            // 3. Setup Lighting
            const light = new THREE.HemisphereLight(0xffffff, 0x777788, 2.5);
            light.position.set(0.5, 1, 0.75);
            scene.add(light);

            // 4. Setup Controls (FPS Style)
            controls = new PointerLockControls(camera, document.body);

            const instructions = document.getElementById('instructions');
            instructions.addEventListener('click', function () {
                controls.lock();
            });

            controls.addEventListener('lock', function () {
                instructions.style.display = 'none';
            });

            controls.addEventListener('unlock', function () {
                instructions.style.display = 'block';
            });

            scene.add(controls.getObject());

            // Movement key listeners
            const onKeyDown = function (event) {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = true; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                    case 'ArrowRight': case 'KeyD': moveRight = true; break;
                }
            };

            const onKeyUp = function (event) {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight': case 'KeyD': moveRight = false; break;
                }
            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // 5. Build the Park

            // Ground (Grass)
            const floorGeometry = new THREE.PlaneGeometry(200, 200, 20, 20);
            const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x4C9A2A });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            // Random Trees
            const treeGeo = new THREE.ConeGeometry(2, 8, 8);
            const treeMat = new THREE.MeshStandardMaterial({ color: 0x2E8B57 });
            const trunkGeo = new THREE.CylinderGeometry(0.5, 0.5, 2);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });

            for (let i = 0; i < 40; i++) {
                // Simple Tree Group
                const treeGroup = new THREE.Group();
                const foliage = new THREE.Mesh(treeGeo, treeMat);
                foliage.position.y = 5;
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.y = 1;
                
                treeGroup.add(trunk);
                treeGroup.add(foliage);

                // Random Position (avoid center)
                const x = Math.random() * 100 - 50;
                const z = Math.random() * 100 - 50;
                
                // Keep center clear for the structure
                if(Math.abs(x) > 5 || Math.abs(z) > 5) {
                    treeGroup.position.set(x, 0, z);
                    scene.add(treeGroup);
                }
            }

            // 6. The Center Structure
            const podiumGeo = new THREE.CylinderGeometry(2, 2.5, 1, 32);
            const podiumMat = new THREE.MeshStandardMaterial({ color: 0x808080 });
            const podium = new THREE.Mesh(podiumGeo, podiumMat);
            podium.position.set(0, 0.5, 0);
            scene.add(podium);

            // 7. The PNG Sprite (Always faces camera)
            // Using a placeholder image of a robot
            const map = new THREE.TextureLoader().load('https://robohash.org/player1.png?size=200x200'); 
            const material = new THREE.SpriteMaterial({ map: map });
            const sprite = new THREE.Sprite(material);
            
            sprite.position.set(0, 2.5, 0); // On top of podium
            sprite.scale.set(3, 3, 1); // Resize sprite
            scene.add(sprite);

            // 8. The Chat Box (Always faces camera)
            // We generate a texture from an HTML Canvas dynamically
            chatMaterial = new THREE.SpriteMaterial();
            chatSprite = new THREE.Sprite(chatMaterial);

            chatSprite.position.set(0, 4.5, 0); // Above the player sprite
            chatSprite.scale.set(4, 2, 1); // Aspect ratio of the canvas
            scene.add(chatSprite);

            updateChatMessage(pendingAssistantMessage);


            // 9. Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize);
        }

        // Helper to create text texture for chat bubble
        function createTextTexture(message) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 256;

            // Bubble style
            ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
            roundRect(ctx, 10, 50, 490, 150, 20, true);

            // Text style
            ctx.font = "Bold 32px Arial";
            ctx.fillStyle = "black";
            ctx.textAlign = "center";

            const maxWidth = 470;
            const maxLines = 3;
            const textLines = wrapAndClampText(ctx, message || DEFAULT_CHAT_MESSAGE, maxWidth, maxLines);
            const lineHeight = 42;
            const textAreaHeight = 150;
            const startY = 50 + (textAreaHeight - (lineHeight * textLines.length)) / 2 + lineHeight / 2;

            textLines.forEach((line, index) => {
                ctx.fillText(line, 256, startY + index * lineHeight);
            });

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function wrapAndClampText(ctx, message, maxWidth, maxLines) {
            const words = message.split(/\s+/).filter(Boolean);
            if (!words.length) return [''];

            const lines = [];
            let currentLine = '';

            for (let i = 0; i < words.length; i++) {
                const word = words[i];
                const nextLine = currentLine ? `${currentLine} ${word}` : word;

                if (ctx.measureText(nextLine).width <= maxWidth) {
                    currentLine = nextLine;
                    continue;
                }

                if (lines.length === maxLines - 1) {
                    const remaining = [currentLine, ...words.slice(i)].filter(Boolean).join(' ');
                    lines.push(clampLine(ctx, remaining, maxWidth));
                    return lines;
                }

                if (currentLine) {
                    lines.push(currentLine);
                } else {
                    lines.push(clampLine(ctx, word, maxWidth));
                }

                currentLine = '';
            }

            if (lines.length === maxLines) {
                return lines;
            }

            if (currentLine) {
                lines.push(currentLine);
            }

            return lines.slice(0, maxLines);
        }

        function clampLine(ctx, text, maxWidth) {
            let clamped = text;
            const ellipsis = 'â€¦';

            while (ctx.measureText(clamped + ellipsis).width > maxWidth && clamped.length > 0) {
                clamped = clamped.slice(0, -1);
            }

            return clamped.length < text.length ? clamped + ellipsis : clamped;
        }

        // Canvas drawing helper
        function roundRect(ctx, x, y, width, height, radius, fill) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) ctx.fill();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateChatMessage(message) {
            pendingAssistantMessage = message || DEFAULT_CHAT_MESSAGE;
            if (!chatMaterial) return;

            if (chatMaterial.map) {
                chatMaterial.map.dispose();
            }

            chatMaterial.map = createTextTexture(pendingAssistantMessage);
            chatMaterial.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            
            if (controls.isLocked === true) {
                const delta = (time - prevTime) / 1000;

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize(); // this ensures consistent movements in all directions

                if (moveForward || moveBackward) velocity.z -= direction.z * 100.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 100.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
            }

            prevTime = time;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>